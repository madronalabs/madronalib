// madronalib: a C++ framework for DSP applications.
// Copyright (c) 2020-2022 Madrona Labs LLC. http://www.madronalabs.com
// Distributed under the MIT license: http://madrona-labs.mit-license.org/

#pragma once

// Here is the DSP vector size, an important constant.
constexpr size_t kFloatsPerDSPVectorBits = 6;
constexpr size_t kFloatsPerDSPVector = 1 << kFloatsPerDSPVectorBits;
static_assert((kFloatsPerDSPVectorBits <= 8),
              "We count on kFloatsPerDSPVectorBits to be 8 or less.");

// Load definitions for low-level SIMD math.
// These must define SIMDVectorFloat, SIMDVectorInt, their sizes, and a bunch of
// operations on them. We are currently only using 4-element vectors on both SSE
// and NEON.

#if (defined __ARM_NEON) || (defined __ARM_NEON__)

// NEON

#define ML_SSE_TO_NEON
#include "MLDSPMathNEON.h"

#else

// SSE2

#include "MLDSPMathSSE.h"

#endif

// A C++11 implementation of std::integer_sequence from C++14
// Copyright Jonathan Wakely 2012-2013
// Distributed under the Boost Software License, Version 1.0.
//
//  Boost Software License - Version 1.0 - August 17th, 2003
//
//  Permission is hereby granted, free of charge, to any person or organization
//  obtaining a copy of the software and accompanying documentation covered by
//  this license (the "Software") to use, reproduce, display, distribute,
//  execute, and transmit the Software, and to prepare derivative works of the
//  Software, and to permit third-parties to whom the Software is furnished to
//  do so, all subject to the following:
//
//  The copyright notices in the Software and this entire statement, including
//  the above license grant, this restriction and the following disclaimer,
//  must be included in all copies of the Software, in whole or in part, and
//  all derivative works of the Software, unless such copies or derivative
//  works are solely in the form of machine-executable object code generated by
//  a source language processor.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.

/// A type that represents a parameter pack of zero or more integers.
template <typename T, T... I>
struct ml_integer_sequence
{
  static_assert(std::is_integral<T>::value, "Integral type");

  using type = T;

  static constexpr T size = sizeof...(I);

  /// Generate an ml_integer_sequence with an additional element.
  template <T N>
  using append = ml_integer_sequence<T, I..., N>;

  using next = append<size>;
};

template <typename T, T... I>
constexpr T ml_integer_sequence<T, I...>::size;

template <std::size_t... I>
using ml_index_sequence = ml_integer_sequence<std::size_t, I...>;

namespace detail
{
// Metafunction that generates an ml_integer_sequence of T containing [0, N)
template <typename T, T Nt, std::size_t N>
struct iota
{
  static_assert(Nt >= 0, "N cannot be negative");
  using type = typename iota<T, Nt - 1, N - 1>::type::next;
};

// Terminal case of the recursive metafunction.
template <typename T, T Nt>
struct iota<T, Nt, 0ul>
{
  using type = ml_integer_sequence<T>;
};
}  // namespace detail

// ml_make_integer_sequence<T, N> is an alias for ml_integer_sequence<T,
// 0,...N-1>
template <typename T, T N>
using ml_make_integer_sequence = typename detail::iota<T, N, N>::type;

template <int N>
using ml_make_index_sequence = ml_make_integer_sequence<std::size_t, N>;

// ml_index_sequence_for<A, B, C> is an alias for ml_index_sequence<0, 1, 2>
template <typename... Args>
using ml_index_sequence_for = ml_make_index_sequence<sizeof...(Args)>;
